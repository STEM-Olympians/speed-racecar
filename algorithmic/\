import sys
import numpy as np
from datetime import datetime
import time
import math
import matplotlib.pyplot as plt

sys.path.insert(0, "../library")
from racecar_core import create_racecar
import racecar_utils

class KMeans:
    def __init__(self, arr: np.ndarray, k: int):
        """
            arr: np.ndarray
                expected array with zero'd non-far distances
        """
        self.arr = arr
        self.k   = k

    def cluster() -> np.ndarray:
        cluster_indexes = np.random.rand(1,  self.k)


class Algorithmic:
    def __init__(self):
        self.car = create_racecar()
        self.speed = 0.5

        self.turn_history = [0] # determine next turn based on similarity to previous turns to prevent issues with committing to turns.

    def getHighestSummedWindowIndex(self, lidar):
        stddev = np.std(lidar, ddof=0)*2
        deviated = [i for i in lidar if i > -abs(stddev) and i < abs(stddev)]
        #print("deviated ", deviated)

        VIEW_BUFFER_SIZE = 72
        summed_buffer_array = []
        i = 0
        #print("iterations ", len(lidar)/VIEW_BUFFER_SIZE)
        while i < len(lidar):
            summed_buffer_array.append([sum(lidar[i:i+VIEW_BUFFER_SIZE]), i, i+VIEW_BUFFER_SIZE]) # Keep track of high and low indexes in order to decode.
            i += VIEW_BUFFER_SIZE # note: if there are issues with data, i+100 turn to i+99.

        resulting = summed_buffer_array[0]
        print(resulting)
        for i in range(len(summed_buffer_array)):
            if summed_buffer_array[i][0] > resulting[0]:
                resulting = summed_buffer_array[i]
        #for i in range(len(resulting)):
        print("Resulting Value ", resulting)

        #print("RESULTING ", summed_buffer_array)
        firstWindowIndex = resulting[1]
        secondWindowIndex = resulting[2]
        return (firstWindowIndex, secondWindowIndex)


    def getHighestLidar(self, lidar_array):
        lidar_array = np.array(lidar_array)

        first = lidar_array[0:180]
        second = lidar_array[540:-1]
        lidar = np.append(second, first)


        print("SIZE FIRST ", len(first))
        print(first)
        print("SIZE SECOND ", len(second))

        firstWindowIndex, secondWindowIndex = self.getHighestSummedWindowIndex(lidar)
        firstWindowIndex, secondWindowIndex = 500, 720

        idx = np.argmax(lidar[firstWindowIndex:secondWindowIndex])

        distance = lidar[idx]
        """
        angle = idx/180
        angle -= 1
        """

        angle = idx
        A_constant = math.pi

        angle /= 180 # 0 to 2
        angle -= 1 # shift the non-linear angle to be from -1 to +1
        angle_nl = angle ** 2 # Non-linear angle: from 0 to 1, but more angles accumulate in the lower half from 0 to 0.5
        angle_nl = A_constant* angle_nl if angle_nl * A_constant < 1 else 1

        """
        if angle_nl < 1.0:
            angle_nl = 1.0
        """

        turn_angle = -angle_nl if angle < 0 else angle_nl

        return turn_angle


    def getSimilarAngle(self, angles):
        #reference = sum(self.turn_history)/len(self.turn_history) # so my brain doesn't get lost again
        reference = self.turn_history[-1]

        ref = np.array([])
        for i in range(len(angles)):
            ref = np.append(ref, abs(angles[i]-reference))

        return angles[np.argmin(ref)] # will return angle with minimum distance to the relative angle

    def start(self):
        self.car.drive.set_max_speed(self.speed)
        self.car.drive.stop()
        self.car.set_update_slow_time(1)

        self.start = time.time() # defined in start() to remain unchanged by update() resets.

        self.lidar = self.car.lidar.get_samples()


        self.angleToTurn = self.getHighestLidar(self.lidar) # defined in start() to be changed when turn finishes and not when update() resets.

        self.turn_history.append(self.angleToTurn)

        self.car.drive.set_speed_angle(self.speed, self.angleToTurn)
        self.angvel = self.car.physics.get_angular_velocity()[0]

        self.travel_time = (self.angvel/self.angleToTurn)

    def update(self):
        if time.time()-self.start >= self.travel_time:
            self.lidar = self.car.lidar.get_samples()

            self.angleToTurn = self.getHighestLidar(self.lidar) # defined in start() to be changed when turn finishes and not when update() resets.z
            print(self.angleToTurn)
            self.turn_history.append(self.angleToTurn)

            self.angvel = self.car.physics.get_angular_velocity()[0]

            self.travel_time = (self.angvel/self.angleToTurn)

            #print(summed_buffer_array.shape)
            #print(summed_buffer_array)

            """
            # This is just some plotting code to test my procedurally generated lidar data.
            plt.rcParams["figure.figsize"] = [720, 1000]
            plt.rcParams["figure.autolayout"] = True
            y = self.lidar
            x = range(len(y))
            plt.plot(x, y, color="red")
            plt.show()
            """

            self.start = time.time() # defined in start() to remain unchanged by update() resets.
            self.car.drive.set_speed_angle(self.speed, self.angleToTurn)
        else:
            self.car.drive.set_speed_angle(self.speed, 0)

    def update_slow(self):
        pass


if __name__ == "__main__":
    a = Algorithmic()
    a.car.set_start_update(a.start, a.update, update_slow=a.update_slow)
    a.car.go()
